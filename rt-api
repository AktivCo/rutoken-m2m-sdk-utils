#!/bin/sh


#this script used as a library in other rt-utils

Bold='\e[1m'
Red='\e[31m'
Green='\e[32m'
Yellow='\e[93m'
Purple='\e[35m'

End='\e[0m'

print_error(){
	echo " "
	echo -e "${Red}Error${End}: ${Bold}$1${End}"
}

print_succeed(){
	echo " "
	echo -e "${Green}Success${End}: ${Bold}$1${End}"
}

print_info(){
	echo " "
	echo -e "${Yellow}Info${End}: ${Bold}$1${End}"
}

exit_if_not_root(){

	user_id=$(id -u)
	if [ "$user_id" -ne 0 ]; then
		print_error "run as root"
		exit 1
	fi
}

is_pcscd_running(){

	if [ -f /var/run/pcscd/pcscd.pid ]; then
		pcscd_pid=$(cat /var/run/pcscd/pcscd.pid | tr -d '\0')
		if [ -d "/proc/$pcscd_pid" ]; then
			true
        else
			false
        fi
	else
		false
	fi

	return
}

stop_pcscd(){

	exit_if_not_root

	if is_pcscd_running; then
		kill $pcscd_pid
		timeout 5 sh -c 'while true; do start-stop-daemon -T -p /var/run/pcscd/pcscd.pid; if [ $? -eq 3 ]; then exit 3; fi; done'
		if [ $? -ne 3 ]; then
			print_error "can't kill pcscd"
			exit 1
		fi
		true
	else
		false
	fi

	return
}

init_log(){

	log_config_path="/tmp/rtm_log.config"

	if [ ! -f $log_config_path ]; then
		touch $log_config_path
	fi

	pcscd_flags=''
	ccid_env=''
	rtuart_env=''
}

read_log_config(){

	init_log

	pcscd_flags=$(cat $log_config_path | grep pcscd_flags | cut -d '=' -f2)

	ccid_env=$(cat $log_config_path | grep LIBCCID_ifdLogLevel)

	rtuart_env=$(cat $log_config_path | grep LIBRTUART_ifdLogLevel)
}

start_pcscd(){

	exit_if_not_root

	if is_pcscd_running; then
		false
	else
		read_log_config

		env_variables="$ccid_env $rtuart_env"
		sh -c "$env_variables start-stop-daemon -SbC -p /var/run/pcscd/pcscd.pid -x /usr/sbin/pcscd -- $pcscd_flags 1>/dev/null 2>/dev/null"
		timeout 5 sh -c 'while true; do start-stop-daemon -T -p /var/run/pcscd/pcscd.pid; if [ $? -eq 0 ]; then exit 0; fi; done'
		if [ $? -ne 0 ] ; then
			print_error "can't start pcscd"
			exit 1
		fi
		true
	fi

	return
}

is_usb_connected(){

	if  lsusb | grep -q "0a89:0030"; then
		true
	else
		false
	fi
	return
}

check_gpio_status(){

	case $1 in
		usb)
			bcm=26
		;;
		uart)
			bcm=23
		;;
		sc)
			bcm=27
		;;
		interface)
			bcm=22
		;;
	esac

	if [ ! -d /sys/class/gpio/gpio$bcm ]; then
		true
		return
	fi

	if grep -q 'in' /sys/class/gpio/gpio$bcm/direction; then
		true
		return
	fi

	gpio_value=$(cat /sys/class/gpio/gpio$bcm/value)

	gpio_active_low=$(cat /sys/class/gpio/gpio$bcm/active_low)

	if [ $gpio_value -eq $gpio_active_low ]; then
		true
	else
		false
	fi

	return
}

reset_gpio(){

	if [ -d "/sys/class/gpio/gpio$1" ]; then
		echo $1 > /sys/class/gpio/unexport
	fi

	echo $1 > /sys/class/gpio/export
}

setup_gpio(){

	reset_gpio $1

	echo $2 > "/sys/class/gpio/gpio$1/direction"
	if [ ! -z $3 ]; then
		echo $3 > "/sys/class/gpio/gpio$1/value"
	fi
}

switch_gpio_state(){

	case $1 in
		usb)
			bcm=26
		;;
		uart)
			bcm=23
		;;
		sc)
			bcm=27
		;;
		interface)
			bcm=22
		;;
	esac

	power=0
	if [ $2 = "off" ]; then
		power=1
	fi

	setup_gpio $bcm 'out' $power
}

set_interface_sc(){

	exit_if_not_root
	switch_gpio_state "interface" "off"
}


set_interface_uart(){

	exit_if_not_root
	switch_gpio_state "interface" "on"
}

is_interface_uart(){
	if check_gpio_status "interface" ; then
		true
	else
		false
	fi
	return
}

hide_librtuart(){

	if [ -f /etc/reader.conf.d/librtuart ]; then
		mv /etc/reader.conf.d/librtuart /etc/reader.conf.d/.librtuart
	fi
}

reveal_librtuart(){
	if [ -f /etc/reader.conf.d/.librtuart ]; then
		mv /etc/reader.conf.d/.librtuart /etc/reader.conf.d/librtuart
	fi
}

is_librtuart_hidden(){
	if [ -f /etc/reader.conf.d/.librtuart ]; then
		true
	else
		false
	fi
	return
}

is_4010_enabled(){
	if ! is_interface_uart; then
		false
		return
	fi

	check_gpio_status "uart"
	if [ $? -ne 0 ]; then
		false
	fi

	if is_librtuart_hidden; then
		false
		return
	fi

	true
	return
}

is_21xx_enabled(){
	if is_interface_uart; then
		false
		return
	fi

	check_gpio_status "sc"
	if [ $? -eq 0 ]; then
		false
		return
	fi

	true
	return
}

is_2010_enabled(){
	if ! is_usb_connected; then
		false
		return
	fi

	check_gpio_status "usb"
	if [ $? -ne 0 ]; then
		false
		return
	fi

	true
	return
}

enable_devices(){

	exit_if_not_root

	usb=$1
	uart=$2
	sc=$3

	if [ $usb = "off" ]; then
		if is_usb_connected; then
			switch_gpio_state "usb"  "off"
		fi
	else
		switch_gpio_state "usb"  "on"
		timeout 5 sh -c 'while true; do  if lsusb | grep -q "0a89:0030"; then exit 0; fi; done'
		if [ $? -ne 0 ] ; then
			print_error "unable to power on Rutoken 2010; Runtoken 2010 is not connected by usb"
			exit 1
		fi
	fi

	if [ $uart = "off" ]; then
		hide_librtuart
		set_interface_sc
		switch_gpio_state "uart" "off"

	else
		reveal_librtuart
		set_interface_uart
		switch_gpio_state "uart" "on"
	fi

	if [ $sc = "off" ]; then
		set_interface_uart
		switch_gpio_state "sc" "off"
	else
		set_interface_sc
		switch_gpio_state "sc" "on"
	fi
}
